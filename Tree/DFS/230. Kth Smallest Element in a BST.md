# question
![img_1.png](https://github.com/WeiruSun/Leetcode/blob/66476c3c4bcea2263c9713a7e9a7039676903ffd/Tree/DFS/img.png)
![img.png](https://github.com/WeiruSun/Leetcode/blob/22ad21e4670232b881313b3279814656404eda9f/Tree/DFS/img.png)

 ```
 class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        current = root

        while current or stack:
            while current:
                stack.append(current)
                current = current.left
            current = stack.pop()
            k -=1
            if k ==0:
                return current.val
            current = current.right
```

**Time complexity: O(H + k)**

where H is a tree height. This complexity is defined by the stack, which contains at least H+k elements, since before starting to pop out one has to go down to a leaf. 